#####    基础

- HashMap

  - 基本数据结构：数组 + 链表 + 红黑树。
  
  - 关键的设计点：数组长度始终保持2的幂，这样可以使用&运算求余数，提升效率。
  
  - 计算hash方法：让高16位也参与运算。
  
  - 扩容：扩容为之前的2倍，根据容量是2的幂的特点，新的下标计算可以根据，原hash对应老容量二进制的1的位的结果，如果是0，下标相同，如果是1，下标等于原下标加老容量。
  
  - put过程：1.8中线程安全在put里，A线程先判断当前节点为空，时间片结束被挂起，B线程同样的判断，将node直接插入，A被唤醒，不会再次判断，直接插入，导致数据覆盖。
  
  - 1.7的线程安全问题：扩容的时候，形成循环链表，1.8使用尾插法代替头插法解决这个问题。
  
    由于头插法的缘故，假设两个线程 T1和T2，需要扩容的节点，链表两个元素 A -> B，1.7中，T1和T2都会获取到当前节点和下一个节点的引用。T1开始执行扩容，将A元素放到扩容后table中链表头部，再将B放到头部，由于原链表B是末尾节点，所以结束，形成 B -> A 的链表，完成扩容。对于 T2 线程来说，它依然会从 A 节点开始处理，将A放到新链表头部，取出A的下一个节点B，将B放到头部，再次获取 B 的下一个节点，由于被T1线程修改了，B的下个节点为A，导致死循环
- ConcurrentHashMap

  - 数据结构：后续补充
  - 怎样实现线程安全：后续补充
- java锁

  - synchronized锁
    - 锁状态：无锁、偏向锁、轻量锁、重量锁。
    - 锁升级：四种状态的升级过程，主要是随着竞争一步步升级。对象被创建时，默认是匿名偏向的状态，如果此时有线程需要获取锁，锁会成为偏向锁状态，再来一个线程竞争资源，偏向锁将升级为轻量锁，此时处于等待的线程自旋次数过多（一般10次）或者又来了更多的线程竞争资源，这将导致轻量锁升级到重量锁。
  - reentrantlock锁
    - cas操作：compare and swap，cpu已经支持的原子操作，主要思想是，修改一个值时，先比较原来的值是否没有变化，如果改变了就不会进行修改，否则将进行修改，以此来保证数据正确。
    - aqs框架：基于cas，多个线程调用cas操作，将会导致只有一个线程成功，其他线程等待情况，aqs主要是对这些线程进行管理，以双向链表的队列结构来进行管理，头结点相当于虚结点，或者说已经获取到锁的节点，其他线程节点都在队列中，那么第二个节点将会自旋等待锁释放，第三个及之后的节点将被挂起，以此来节约资源。
    - 公平锁和非公平锁：基于aqs
      - 公平锁：新来的线程直接入队，排队等待。
      - 非公平锁：新来的线程会先尝试竞争，如果获取锁成功，就实现了插队的效果，否则入队等待。
  - 自旋锁：一直循环等待锁的状态称为自旋锁。
  - 适应性自旋锁：循环等待锁，是比较耗资源的，因此jvm会进行优化，如果曾经成功获取到这个锁，那么jvm认为这次自旋也是很有可能获得锁，所以会将它自旋的时间设置的更久一些。如果从来没有获取锁成功过，那么这次大概率也不会成功，所以会直接将线程挂起。
  - 可重入锁：同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前自己的锁没释放而阻塞，synchronized和reentrantlock都是可重入锁。
  - 不可重入锁：NonReentrantLock
  - 读写锁：后续补充
- juc包下的类：countdownlatch的使用。
- java线程：

  - 状态：创建、就绪、运行、阻塞、死亡。
  - 创建线程的两种方式：继承thread、实现runnable接口。
  - volatile关键字：线程可见和禁止指令重排。
- java线程池：

  - 基本模型：设置核心线程数n，这n个线程将会承担n个工作任务，如果任务数大于n，多出的任务将被放置到阻塞队列中进行排队，如果队列也满了，只能按最大的线程数开启线程进行工作，如果都满了，则执行拒绝策略。
  - 四种拒绝策略：
    - 不接受任务并抛异常。
    - 反馈给调用线程，也就是开启线程的主线程，让主线程自己来执行任务。
    - 默默抛弃新提交的任务。
    - 接收新任务，相应的，把最老的任务抛弃。
  - 三种线程池：
    - 无界线程池：队列无界，核心线程数设置为0，最大线程数设置为int最大值，队列为同步队列，当来了任务交给队列，此时创建线程执行任务。
    - 固定大小线程池：核心线程数与最大线程数设置相同。
    - 单一线程池，核心线程数与最大线程数都设置为1。
  - 关闭机制：
    - 有序关闭：执行先前提交的任务，但不接受新任务。
    - 立即关闭：尝试停止所有正在执行的任务，暂停正在等待的任务，并返回这些等待的任务列表。
- jvm和gc相关：
  - jvm内存划分模型
  - gc
  - jvm调优

##### 框架（spring）

- spring自动装配原理：spi机制，以及@import注解的实现。
- spring bean生命周期：bean定义 -> 实例化 -> 填充属性 -> 初始化，以及其中可扩展的点。
- spring ioc容器：可以理解为特指singleObjects这个map容器，最终实例化后的bean都会放在这里。
- spring aop：切面思想。
- springboot启动流程：简单来讲，run方法被监听，不同的阶段发布不同信号，由监听者完成具体功能。
- spring事务
  - 传播机制：7种机制。
  - 隔离级别：默认使用数据库的级别。

##### mysql

- 索引结构：b+树，分析其他结构不适合的原因。
- 根据索引结构引发的问题：
  - 最左匹配：联合索引在匹配时，从第一个开始匹配。
  - 回表：在普通索引查询出结果后，需要再次查询主键索引树获取完整结果。
  - 索引覆盖：针对回表操作，尽量避免回表，将要查询的字段设置为索引，这样可以一次查询出普通索引和主键，就不需要再次回表。
  - 索引下推：mysql5.7之前没有，查询使用多个索引条件，首先根据第一个条件获取结果集，返回到server端，根据其他条件过滤，获得最终结果。有了索引下推，查询会在存储引擎层直接使用多条件过滤最终结果。
- mysql锁
  - 行锁：针对索引上锁都是行锁。
  - 表锁：不是对索引上锁都是表锁。
  - 意向锁：要想对行上锁，需要先对库、表、页进行上锁，这些粗粒度的锁称为意向锁。
  - 排他锁和共享锁：简单说，共享锁之间兼容，其他情况都不兼容，必须等待其他锁释放才可以加锁。读锁是共享锁。
- mysql事务隔离级别
  - 读未提交：会引发脏读、不可重复读、幻读的问题。
  - 读已提交：解决了脏读问题，但是不可重复读和幻读依然存在。
  - 可重复读：mysql默认级别，解决了所有的问题，已经可以达到sql标准里的串行化级别，核心技术是，使用自研的next key locking 和 previous key locking算法，由锁记录变成锁区间，假设有1条记录（1），那么算法会将它拆分为：(负无穷，1]，（1，正无穷），此时加锁，会锁住前面区间，不允许其他事务往负无穷到1的区间内写入，所以可以保证没有幻读情况。
  - 串行化：效率太低。
- mysql事务实现机制：undo log 和 redo log。
- mysql bin log，慢查询日志。
- sql调优。

##### redis

- redis五大数据结构
- redis持久化机制
- redis io模型
- redis 数据结构的底层实现
- redis 分布式锁的实现，redisson
- 缓存击穿、穿透、雪崩问题

##### 高并发优化

- 服务降级

- 限流

  

  

