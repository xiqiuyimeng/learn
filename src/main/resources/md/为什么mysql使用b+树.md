##### 为什么mysql使用b+树

- 二叉树：
  - 不适合单边增长的情况，会退化成链表
- avl 平衡二叉树：
  - 严格平衡，左子树和右子树高度差不超过1
  - 树越高，查找速度越慢
  - 范围查找，回旋查找比较慢
- 红黑树：
  - 树的深度过深
  - 非严格平衡，最长子树不超过最短子树两倍
- b树：
  - 一个节点可以存多个值，导致树结构变矮
  - 同样存在回旋查找问题
- b+ 树：
  - 一个节点可以存多个值
  - 最底层的是叶子节点，既存储索引也存储数据，是一个链表结构，包含所有索引子段
    - 如果存在主键或唯一索引，叶子节点存放索引和行记录数据，不存在这俩，innodb会创建一个6字节的主键，和数据存放在一起构成聚簇索引
    - 如果是其他类型索引，innodb叶子节点存储的是索引和聚簇索引中叶子节点的索引值
  - 上层非叶子节点只存索引和下一层指针（指针大小6字节，单个页大小16kb），可以存放更多的索引，导致树高度降低，假设三层树，索引类型int 4字节，数据记录大小1kb，那么共可以存放：16k/ (6+4) x 16k/ (6+4) x 16k/1k = 4096 0000，4千万条记录。支持千万级别的数据量，大概是3-4层树结构，索引值应尽可能少占用空间，这样可以存放更多。
  - 叶子节点的链表结构，提高了区间访问的性能，对范围查找友好
  - 索引维护，在插入或更新一条记录都会触发索引维护
    - 页分裂，
      - innodb默认分裂因数15/16，当存储的数据达到分裂因数，会分裂出一个新的页来存储
      - 在使用非自增主键，由于主键无序，插入到之前的页，会导致之前页分裂为两半，将新的数据插入到这两个其中之一，有可能会导致上层节点的分裂，进而导致更大的维护开销。
  - 回表：通过普通索引查询到聚簇索引的索引值后，需要再查询一次聚簇索引，取出数据，称为回表
  - 索引覆盖：当要查询的字段只涉及聚簇索引的索引值和普通索引值，这时候，查询普通索引的时候，能获取到普通索引 + 聚簇索引的索引值，所以不需要再回表查询。
  - 最左匹配：联合索引，使用时必须按照从左到右的顺序出现，例如索引 abc
    - 生效情况：abc，ab，a，cba（优化器会将其优化为abc）
    - 不生效情况：bc，ac
    - 建立联合索引，叶子节点存储索引为(abc)，在查询时，都会从第一个开始匹配
  - 索引下推：mysql5.7之前没有，之后默认开启。
    - 没有索引下推：查询的时候使用多个索引条件，会首先根据第一个条件从存储引擎取出结果到server层，由server层进行后续条件的过滤。
    - 有了索引下推：查询的时候，会使用多个条件在存储引擎中，直接取出合适的数据。